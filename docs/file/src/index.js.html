<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/index.js | redux-endpoints</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Redux modules for API endpoints"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="redux-endpoints"><meta property="twitter:description" content="Redux modules for API endpoints"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/dylanonelson/redux-endpoints"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createEndpoint">createEndpoint</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-dataSelector">dataSelector</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-errorSelector">errorSelector</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isPendingSelector">isPendingSelector</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-actionTypeCase">actionTypeCase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-camelCase">camelCase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-initialEndpointState">initialEndpointState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DEFAULT_KEY">DEFAULT_KEY</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/index.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import URL from &apos;url-parse&apos;;

import { DEFAULT_KEY } from &apos;./constants&apos;;
import { camelCase, actionTypeCase, initialEndpointState } from &apos;./utils&apos;;

export {
  dataSelector,
  errorSelector,
  isPendingSelector,
} from &apos;./selectors&apos;;

export { initialEndpointState };

const defaultResolver = () =&gt; DEFAULT_KEY;

/**
 * @param {!Object} options
 * @param {!string} options.name The name for this endpoint. Will be used to
 * derive the action names. Must be provided in spinal case. E.g. `my-api` will
 * be transformed to action name `myApi/MAKE_MY_API_REQUEST`.
 * @param {!function(url: string, options: Object)} options.request
 * Takes the url to be requested as well as an options object optionally
 * supplied to the `request` action creator. Must return a Promise object which
 * resolves with the successfully requested data and rejects with either a
 * string value or an Error object.
 * @param {!string} options.url
 * The url to be requested when store dispatches the `request` action. May
 * include any number of url parameters denoted by colons. E.g.
 * `&apos;/myapi/content/:id&apos;`.
 * @param {?function} options.resolver
 * Takes as its arguments the url parameters denoted in options.url with colors.
 * Takes as its last, optional argument an options object.
 *
 * @return {Object} endpoint
 * @property {Object} actionCreators
 * @property {function} actionCreators.ingest
 * The ingest action creator is primarily for internal use, but it is exported
 * because its `toString` method returns its action type.
 * @property {function} actionCreators.request
 * Takes as its arguments the url parameters denoted in options.url with colons.
 * E.g. `&apos;/myapi/content/:id&apos;` results in a request action creator that takes
 * one argument, the `id` parameter. In addition, takes as its last, optional
 * argument an options object to pass in turn to the options.request function.
 * @property {function} selector Takes the same arguments as the passed
 * resolver. If no resolver is supplied, it receives no arguments. Returns a
 * selector that takes the root piece of state where this endpoint&apos;s data is
 * stored and returns the piece of state for the url that the arguments resolve to.
 * @property {function} reducer Redux reducer.
 * @property {function} middleware Redux middleware.
 */
export const createEndpoint = ({
  name,
  request,
  url,
  resolver = defaultResolver,
}) =&gt; {
  const actionTypeCaseName = actionTypeCase(name);
  const camelCaseName = camelCase(name);

  const parsedUrl = new URL(url);
  // Thanks, Jeremy
  const namedParam = /(\(\?)?:\w+/g;
  const urlParams = [];

  let match = true;

  while (match) {
    match = namedParam.exec(parsedUrl.pathname);
    if (match) urlParams.push(match[0]);
  }

  const ingestActionType =
    `${camelCaseName}/INGEST_${actionTypeCaseName}_RESPONSE`;

  const requestActionType =
    `${camelCaseName}/MAKE_${actionTypeCaseName}_REQUEST`;

  const ingestActionCreator = (payload, meta) =&gt; {
    return {
      error: (payload instanceof Error) ? true : false,
      meta,
      payload,
      type: ingestActionType,
    };
  };

  ingestActionCreator.toString = () =&gt; ingestActionType;

  const requestActionCreator = (...params) =&gt; {
    let options = {}, reqUrl = url;

    urlParams.forEach((p, i) =&gt; {
      reqUrl = reqUrl.replace(p, params[i]);
    });

    if (typeof params[params.length - 1] === &apos;object&apos;) {
      options = params[params.length - 1];
    }

    const metaParams = urlParams.reduce((memo, p, i) =&gt; {
      memo[p.replace(&apos;:&apos;, &apos;&apos;)] = params[i];
      return memo;
    }, {});

    return {
      meta: {
        params: metaParams,
        path: resolver(...params),
        url: reqUrl,
      },
      payload: {
        options,
        url: reqUrl,
      },
      type: requestActionType,
    };
  };

  requestActionCreator.toString = () =&gt; requestActionType;

  const actionCreators = {
    ingest: ingestActionCreator,
    request: requestActionCreator,
  };

  const middleware = store =&gt; next =&gt; action =&gt; {
    if (action.type === requestActionType) {
      request(action.payload.url, action.payload.options)
        .then(data =&gt;
          store.dispatch(actionCreators.ingest(data, action.meta))
        )
        .catch(error =&gt; {
          let payload;

          if (error instanceof Error) {
            payload = error;
          } else {
            payload = new Error(error);
          }

          store.dispatch(actionCreators.ingest(payload, action.meta))
        });
    }
    return next(action);
  }

  const reducer = (previous = {}, action) =&gt; {
    let nextState = null;

    if (action.type === requestActionType) {
      nextState = Object.assign({}, previous);
      const path = action.meta.path;
      if (!nextState[path]) {
        const init = initialEndpointState();
        init.pendingRequests = 1;
        nextState[path] = init
      } else {
        nextState[path] = Object.assign({}, nextState[path]);
        nextState[path].pendingRequests += 1;
      }
    } else if (action.type === ingestActionType) {
      nextState = Object.assign({}, previous);
      const path = action.meta.path;
      const nextPathState = Object.assign({}, nextState[path]);
      nextState[path] = nextPathState;

      if (action.error) {
        const { message, name } = action.payload;
        nextPathState.error = { message, name }
      } else {
        nextPathState.data = action.payload;
        nextPathState.error = null;
        nextPathState.successfulRequests = (
          nextPathState.successfulRequests === undefined
            ? 1
            : nextPathState.successfulRequests + 1
        );
      }

      nextPathState.totalRequests = (
        nextPathState.totalRequests === undefined
        ? 1
        : nextPathState.totalRequests + 1
      );
      nextPathState.pendingRequests--;
    }

    if (nextState !== null)
      return nextState;

    return previous;
  };

  const selectorMap = {};

  const selector = (...params) =&gt; {
    const path = resolver(...params);
    let s;

    if (!selectorMap[path]) {
      s = state =&gt; (state[path] &amp;&amp; state[path]) || null;
      selectorMap[path] = s;
    } else {
      s = selectorMap[path];
    }

    return s;
  };

  return {
    actionCreators,
    middleware,
    reducer,
    selector,
  };
};
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
